import kit.map;
import helperfunctions;
import choice;
import argument;
import arguments;


struct Command {
    var sub: Vector[Command];
    var args: Arguments;
    const command: CString = "";
    var map: Map[CString, Int];  // gets a lookup value into the sub vector

    static function new(arguments: Arguments) {
        return struct Self {
            sub: Vector.new(4),
            args: arguments,
            command: "",
            map: Map.new(4)
        };
    }

    static function subNew(command: CString, arguments: Arguments) {
        return struct Self {
            sub: Vector.new(4),
            args: arguments,
            command,
            map: Map.new(4)
        };
    }

    function addArg(shortName: Char = c'_',
                longName: CString = "__",
                defaultValue: Choice = Choice.newInt(0),
                info: CString = "",
                needsValue: Int = no_argument,
                func: function (Choice, Argument, Arguments) -> Void,
                flag: Ptr[Int] = &defaultFlag,
                flagVal: Int = 0) {
        this.args.add(shortName,
                        longName,
                        defaultValue,
                        info,
                        needsValue,
                        func,
                        flag,
                        flagVal);
    }

    function addSubcommand(command: CString, arguments: Arguments) {
        this.map.put(command, this.sub.length);
        this.sub.push(Command.subNew(command, arguments));
    }

    function getSubcommand(command: CString): Command {
        return this.sub[this.map[command]];
    }

    function process(argc: Int, argv: Ptr[Ptr[Char]]): Void {
        // printf("command process\n");
        // printf("{{%s}}\n", argv[1]);
        if this.map.exists(argv[1]) {  // found matching subcommand
            // printf("found matching subcommand\n");
            this.getSubcommand(argv[1]).process(argc - 1, argv + 1);  // recurse with subcommand
        } else {  // found no matching subcommand
            // printf("found no matching subcommand\n");
            this.args.process(argc - 1, argv);  // call process on `Arguments` instance
        }
    }
}
