include "getopt.h";
include "ctype.h";
include "errno.h";
include "string.h";
import kit.map;
import helperfunctions;
import choice;
import argument;


struct Arguments {
    var args: Vector[Argument];
    var map: Map[Char, Int];  // gets a lookup value into the args vector

    static function new() {
        return struct Self {
            args: Vector.new(10),
            map: Map.new(10)
        };
    }

    function add(shortName: CString = "_",
                longName: CString = "__",
                defaultValue: Choice = Choice.newInt(0),
                info: CString = "",
                needsValue: Int = no_argument,
                func: function (Choice, Argument, Arguments) -> Void,
                flag: Ptr[Int] = &defaultFlag,
                flagVal: Int = 0) {
        // printf("---- add() %d\n", needsValue);
        this.map.put(shortName[0], this.args.length);
        this.args.push(Argument.new(shortName,
                                    longName,
                                    defaultValue,
                                    info,
                                    needsValue,
                                    flag,
                                    flagVal,
                                    func));
        // printf("---- add() (query) %d\n", this.args[this.args.length - 1].needsValue);
    }

    function printSep() {
        printf("----------------------------------------\n");
    }

    function printOption() {
        for n in this.args {
            n.printOption();
            n.printDefault();
        }
    }

    function printInfo() {
        for n in this.args {
            n.printInfo();
        }
    }

    function printAll() {
        for n in this.args {
            printf("+---------+-----------------------------\n| ");
            n.printInfo();
            printf("+---------+-----------------------------\n");
            n.printOption();
            n.printDefault();
        }
        printf("+---------+-----------------------------\n");
    }

    function toGetOptStruct(): Ptr[option] {
        var outVec: Vector[option] = Vector.new(this.args.length);
        for n in this.args {
            outVec.push(n.toGetOptStruct());
        }
        var blank = struct option {name: "", has_arg: 0, flag: null, val: 0};
        outVec.push(blank);  // was in the example, so i'm including it here
        var out: Ptr[option] = malloc(outVec.length * sizeof(option));
        for n in 0 ... outVec.length {
            out[n] = outVec[n] as option;
        }
        return out;
    }

    function toGetOptString(): CString {
        var out = "";
        for n in this.args {
            if n.needsValue == no_argument {
                // printf("no_arg - %d\n", n.needsValue);
                out = strAdd(out, n.shortName);
            } else {
                if n.needsValue == required_argument {
                    // printf("req_arg - %d\n", n.needsValue);
                    out = strAdd(strAdd(out, n.shortName), ":");
                } else {
                    if n.needsValue == optional_argument {
                        // printf("opt_arg - %d\n", n.needsValue);
                        out = strAdd(strAdd(out, n.shortName), "::");
                    } else {
                        // printf("bad_arg - %d\n", n.needsValue);
                        printf("Bad value for Self.needsValue: %d", n.needsValue);
                    }
                }
            }
            // printf("- %s\n", out);
        }
        // printf("%s\n", out);
        return out;
    }

    function get(c: Char): Argument {
        // var c_arr: CArray[Char, 40];
        // printf("%s", c);
        // sprintf(c_arr, "%c", c);
        // printf("%c\n", c_arr[0]);
        return this.args[this.map[c]];
    }
}
